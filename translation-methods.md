# Translation Methods

> Лабораторные:
>
> 1. perl
>2. Ручное построение трансляторов
> 3. Использование автоматических генераторов трансляторов
> **e.g.** ANTLR (java), Bison + Yacc (c++), Happy (haskell)
> 4. Написание автоматического генератора транслятора
>    
>    1 - pcms, 2-4 - защита

$\Sigma, \Sigma^*, L \subset \Sigma^*$ - формальный язык

Базовый класс формальных языков - регулярные (= автоматные). Для порождения - регулярные выражния, для распозования - конечные автоматы

Контекстно-свободные языки: КС грамматики / МП автоматы

**токены (лексемы)** - единые неделимые элементы языка ($\in \Sigma$)

## Лексический анализ

Первый этап любого разбора - *лексический анализ*

Последовательность символов -> последовательность токенов ($\in \Sigma^*$)

>  **e.g.** арифмитические выражения
>  
>  $\Sigma = \{n,+,\times,\ (,\ ) \}$
>  
>  $(2 \ + \ 2) \times 2 \rightarrow  (n + n) \times n$
>  
>  $n : (0|1|...|9)(0|1|...|9)^*$

*жадный лексический анализ на базе регулярных выражений*: пропускем пробельные символы, смотрим первый непробельный, находим максимальный префикс какого-то возможного токена

---

1. Проверить, что строка выводится в грамматике $\Gamma$ // алгоритм КЯК $\Omicron(n^3)$

2. Построить дерево разбора

3. Синтаксически управляемая трансляция

    >  $E \rightarrow T \\ E \rightarrow E \ + \ T \\ T \rightarrow F \\ T \rightarrow T \ \times \ F \\ F \rightarrow n \\ F \rightarrow (E)$
    
    **Аттрибуто транслирующие грамматики** - КСГ с добавлением двух элементов: аттрибуты и транслирующие символы

    **транслирующие символы** - фрагменты кода, которые вставляем в грамматику, которые могут взаимодействовать с аттрибутами
    
    >$E \rightarrow E \ + \ T \ \{E_{0}.v = E_{1}.v \ +\ T.v \}$
    >
    >$T \rightarrow T \ \times \ F \ \{T_{0}.v = T_{1}.v \ +\ F.v \}$



Нужно быстрее, чем за куб => накладываем ограничения на грамматики

**Однозначность** - если у любого слова не более одного дерева разбора в этой грамматике  // Модификация алгоритма Эрли - $\Omicron(n^2)$

**LL, LR** - грамматики, на которые наложены дополнительные ограничения, чтобы разбор работал за линейное время



$\Gamma, \ w$ на вход

Можем строить дерево разбора сверзу вниз - **нисходящая трансляция**. Шаг называется *раскрытие нетерминала*

Снизу вверх - **восходящий разбор**. Шаг - *свёртка*

## Метод нисходящих трансляций для LL грамматик

s - стартовый нетерминал, w - слово, префикс которого разобран (x, y left)

**LL(k) - грамматика** - если достаточно посмотреть на первые k символов y, чтобы понять, какое правило применить для нетерминала A

Грамматика $\Gamma$ называется **LL(1) грамматикой**, если $s \Rightarrow^* xA\xi \Rightarrow x \alpha \xi \Rightarrow^* xc\eta \\ s \Rightarrow^* xA\tau \Rightarrow x\beta\sigma \Rightarrow^*xc\zeta \\ \alpha = \beta$

